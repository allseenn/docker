## Контейнеризация

GeekBrains

Ростислав Ромашин

группа 4992

## Урок 3. Введение в Docker

### Задания

1. Запустить контейнер с БД mariaDB, используя инструкции на сайте hub.docker.com.
   Слинковать папку с базой данных с контейнера с mariaDB в папку на хосте (как на семинаре /var/lib/mysql).
   Заполнить БД данными или добавить запись и проверить, что файлы базы данных появились на хостовой машине.
   Если выполняете этот пункт то оценка . Хорошо
2. Запустить phpmyadmin (в контейнере) и через веб проверить, что все введенные данные доступны.
   http://localhost:8081/ Отлично
3. *(не обязательно) Запустить контейнер с postgeSQL и подсоединить к этому контейнеру adminer (графическое управдение базой данных)

   Отлично Формат сдачи ДЗ: предоставить доказательства выполнения задания посредством ссылки на google-документ с правами на комментирование/редактирование.

## Решение

### Задача 1

Т.к. в задание *mariaDB*, а в презентации требуют другую, то выберу *mysql* )

```
docker run --name gb-mysql -e MYSQL_ROOT_PASSWORD=Gb12345 -v ./mydb:/var/lib/mysql -d mysql
```

в команде можно сразу указать имя локальной папки, которая создается автоматически

<img src=pics/01.png>

К консоли подсоединяемся по *id* контейнера

```
docker exec -it 42f16e93d531 bash
```

Логинимся в базу с заданным при запуске контейнера паролем и создаем схему с данными

```
CREATE DATABASE GB; 
USE GB;
CREATE TABLE my_data ( id INT, name VARCHAR(255), surname VARCHAR(255), company VARCHAR(255), group_id INT);
INSERT INTO my_data (id, name, surname, company, group_id) VALUES ('01', 'Ростислав', 'Ромашин', 'GeekBrains', 4992);
```

После выхода в терминал физической машины видим, что в локальной папке появилась новая директория и в ней файл созданной базы данных.

### Задача 2

Запускаем сразу *phpadmin* с автоматической установкой и скачиванием образа, линкуем с существующим *mysql* сервером

```
docker run --name phpmyadmin -d --link gb-mysql:db -p 8081:80 phpmyadmin
```

После имени контейнера с *gb-bmysql* необходимо через двоеточие указать *db* иначе соединение между образами не установится.

С точки зрения безопасности наличие всякого рода админок типа *phpadmin* или *adminer* расширяет векторы атаки, т.к. открывается в нашем случае незащищенное http соединение, где данные передаются отрытым текстом, а наличие php движка на сервере базы данных позволяет проводить php и sql-инъекции.
По хорошему, чем меньше открытых портов, тем лучше.
В идеале это должен быть один порт ssh, базы данных легко работают через него, а современные программы типа dbeaver позволяют соединяться как и с ssl так и с ssh шифрованием.

Но, таковы условия ТЗ )

<img src=pics/02.png>

Видим на картинке адрес физической машины и проброшенные из докера порты, вводим эти данные в браузер, который кричит о не защищенном соединении )

Обязательно необходима реализация веб-серверов с использованием *https!*

<img src=pics/03.png>

После ввода логина и пароля созданного в первой задаче видим наши данные, введенные ранее в базу данных.

### Задача 3

Вводим подрят две команды на установку postgres и пролинкованного к нему *adminer*

```
docker run --name postgres-db -e POSTGRES_PASSWORD=Gb12345 -d -p 5432:5432 postgres
docker run --name adminer -d -p 8080:8080 --link postgres-db:db adminer
```

<img src=pics/04.png>

Образы скачались и контейнеры запустились автоматически

Как видно из команды

```
docker ps
```

Два новых контейнера не мешают работе двух ранее созданных.

<img src=pics/05.png>

Заходим в *adminer* и с помощью веб-интерфейса добавляем необходимые данные в базу *postgres*.
