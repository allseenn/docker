# Домашняя работа № 1

## По предмету Контейнеризация

### Ростислав Ромашин - группа 4992

### Задания

1. Сделать chroot для /bin/bash и перенести в новй корень программу ls - Хорошо.
2. Повторить последовательнсть комманд с ip как на семинаре. - Отлично
3. Повторить последовательнсть комманд с unshare как на семинаре. - Отлично

Формат сдачи ДЗ: предоставить доказательства выполнения задания посредством файла PDF или ссылки на google-документ с правами на комментирование/редактирование. Результатом работы будет: текст объяснения, логи выполнения, история команд и скриншоты (важно придерживаться такой последовательности). В названии работы должны быть указаны ФИ, номер группы и номер урока

### Решение

#### 1. chroot

Воспользовался в своем решении легковесным busybox, который занимает около 700КБ на диске.

```
apt install busybox
```

**BusyBox** - это исполняемый файл командной строки, включающий большой набор системных утилит (ls, rm, md), разработанный для использования во встраиваемых системах и ограниченных окружениях, а так же в образах *Docker*.

Благодаря тому что *busybox* собран методом статической линковки, ему не нужны сторонние библиотеки, т.к. они находятся внутри самого бинарного файла.

<img src=pics/100.png>

Как видно из картинки процесс настройки *chroot* с полноценным набором команд занимает гораздо меньше места нежели процесс с поиском и копированием библиотек для каждой утилиты и команд *linux*.

Только в качестве командного интерпретатора выбирается встроенный в *busybox* классический **sh**.

Настройка *busybox* выполняется командой

```
busybox --install bin
```

Создаются символические ссылки с именем каждой утилиты на сам *busybox*, т.к он в качестве аргумента принимает имя команды, например:

```
busybox ls
```

верхняя команда аналогична команде ls и т.д.

#### 2. ip namespace

Для проведения эксперимента созданы две закладки в терминале:

- Real sys - Реальная система
- Virtual sys - Виртуальная система

<img src=pics/201.png>

В реальной системе с помощью утилиты *ip* создаем netspace *testns*

```
sudo ip netns add testns
```

убеждаемся что неймспейс создан

```
ip netns list
```

создаем два виртуальных сетевых интерфейса

```
sudo ip link add veth0 type veth peer name veth1
```

убеждаемся, что интерфейсы созданы

```
ip a
```

присвоим первому сетевому интерфейсу *veth0* айпи-адрес

```
sudo ip addr add 10.0.0.1/24 dev veth0
```

переведем сетевой интерфейс в активное состояние

```
sudo ip link set dev veth0 up
```

На вкладке виртуальной системы создадим папку *docker* и перейдем в нее

<img src=pics/202.png>

Применим нетспейс *testns* к текущему процессу *bash*

```
sudo ip link set veth1 netns testns
```

как видим кроме "обратной петли" ничего в виртуальной системе не осталось

```
ip a
```

после того как на реальной системе добавили виртуальные интерфейсы, они уже не входят в ранее примененный нетспейс. Второй интерфейс добавим в виртуальную систему прописав ай-пи

```
ip addr add 10.0.0.2/24 dev veth1
```

поднимем сетевой интерфейс для виртуальной системы

```
ip link set dev veth1 up
```

Адреса реальной и виртуальной систем пингуются в обе стороны.

На виртуальной системе, нет доступа к любым другим сетевым ресурсам, что видно на примере

```
ping 8.8.8.8
```

Все icmp-пакеты потеряны

#### 3. unshare

##### 3.1. PID

Активируем неймспейс изолирующий процес *bash* виртуальной системы

<img src=pics/310.png>

для этого создадим с помощью команды *unshare* новое дерево процессов во вновь созданной и смонтированной псевдо директории *proc*

```
sudo unshare --pid --forg --mount-proc
```

на картинке виден запущенный в фоне процесс

```
sleep 20 &
```

виден только в виртуальной системе

```
ps aux
```

Но, данного процесса *sleep* не видно на реальной системе даже с привилегиями супер пользователя

<img src=pics/311.png>

##### 3.2 NET

Действие аналогично действию утилыты *ip* из пункта 2.

<img src=pics/320.png>

после применения команды сетевого нетспейса к процессам виртуальной системы

```
sudo unshare --net /bin/bash
```

остался только loopback интерфейс

##### 3.3 USER

На реальной системе команда *id* отображает полную информацию о текущем пользователе

<img src=pics/330.png>

На виртуальной системе после команды

```
sudo unshare --user /bin/bash
```

для текущего процесса bash применился неймспейс изолирующий от остальных пользователей

<img src=pics/331.png>

На выводе после команды *id* виден пользователь *nobody* группы *nogroup*

##### 3.4. MOUNT

На виртуальной системе после команды

```
sudo unshare --mount /bin/bash
```

применился неймспейс изолирующий все устройства смонтрированные под данным процессом *bash*.
Мы можем только тут наблюдать свеже смонтированный диск /dev/sda1 по лейблу BACKUP в директорию /mnt

<img src=pics/340.png>

Под реальной системой раздела /mnt не видно

<img src=pics/341.png>

Но в логах информация о монтировании видна.

##### 3.5. IPC

Создадим в реальной системе очередь сообщений межпроцесного взаимодействия с помощью команды *ipcmk*

```
ipcmk -Q 1234
```

<img src=pics/350.png>

Очередь с ключом 1234 в шеснадцетиричном счислении 0x8b93d8f4 после создания имеет 0 сообщений.

Обратимся к очереди с помощью пайтона и отправим сообщение *Hello World*

```
import sysv_ipc

key = 0x8b93d8f4
message = b"Hello world"
queue = sysv_ipc.MessageQueue(key)
queue.send(message)
```

Видно, что счетчик сообщений увеличился на единицу и его размер занимает 11 байт

```
ipcs -q 
```

На виртуальной системе при изолированном *IPC* командой

```
sudo unshare --ipc /bin/bash
```

Не видны ни только сообщения, но и очереди межпроцессного взаимодействия

<img src=pics/351.png>

После же выхода из изолированной среды видны и очередь и сообщение в нем

```
ipcs -a
```

С помощью пайтона мы можем прочитать сообщение

```
import sysv_ipc

key = 0x8b93d8f4
queue = sysv_ipc.MessageQueue(key) 
message, _ = queue.receive()
print(message)
```

*Hello world*

##### 3.6. UTS

На виртуальной системе для текущего процесса *bash* произведем изоляцию текущего имени хоста *fen*

```
sudo unshare --uts /bin/bash
```

<img src=pics/361.png>

Теперь поменяем имя хоста на новое

```
echo "NewHostName" > /proc/sys/kernel/hostname
```

Видим, что имя хоста сменилось на *NewHostName*

На реальной системе имя хоста осталось прежним - *fen*

<img src=pics/360.png>

#### unshare и несколько неймспейсов

Применим сразу несколько неймспейсов как было показано на семинаре № 1

```
sudo unshare --pid --net --fork --mount-proc /bin/bash
```

<img src=pics/370.png>
